<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>freshbooks.builders.filter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>freshbooks.builders.filter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from datetime import date, datetime
from typing import Any, Optional, Union, List, Tuple

from freshbooks.builders import Builder


class FilterBuilder(Builder):
    &#34;&#34;&#34;Builder for making filtered list queries.

    Filters can be builts with the methods:
    `equals`, `in_list`, `like`, `between`, and `boolean`, `date_time`
    which can be chained together.

    ```python
    &gt;&gt;&gt; from freshbooks import FilterBuilder

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.like(&#34;email_like&#34;, &#34;@freshbooks.com&#34;)
    FilterBuilder(&amp;search[email_like]=@freshbooks.com)

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.in_list(&#34;clientids&#34;, [123, 456]).boolean(&#34;active&#34;, False)
    FilterBuilder(&amp;search[clientids][]=123&amp;search[clientids][]=456&amp;active=False)

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.boolean(&#34;active&#34;, False).in_list(&#34;clientids&#34;, [123, 456])
    FilterBuilder(&amp;active=False&amp;search[clientids][]=123&amp;search[clientids][]=456)

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.between(&#34;amount&#34;, 1, 10)
    FilterBuilder(&amp;search[amount_min]=1&amp;search[amount_max]=10)

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.between(&#34;start_date&#34;, date.today())
    FilterBuilder(&amp;search[start_date]=2020-11-21)
    ```
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self._filters: List[Tuple[str, str, Any]] = []

    def __str__(self) -&gt; str:
        query_string = self.build()
        return f&#34;FilterBuilder({query_string})&#34;

    def __repr__(self) -&gt; str:  # pragma: no cover
        query_string = self.build()
        return f&#34;FilterBuilder({query_string})&#34;

    def boolean(self, field: str, value: bool) -&gt; Builder:
        &#34;&#34;&#34;Filters results where the field is equal to true or false.

        Example:
        `filter.boolean(&#34;active&#34;, False)` will yield the filter `&amp;active=false`

        Args:
            field: The API response field to filter on
            value: True or False

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        self._filters.append((&#34;bool&#34;, field, value))
        return self

    def equals(self, field: str, value: Any) -&gt; Builder:
        &#34;&#34;&#34;Filters results where the field is equal to the provided value.

        Example:
        `filter.equals(&#34;username&#34;, &#34;Bob&#34;)` will yield the filter `&amp;search[username]=Bob`

        Args:
            field: The API response field to filter on
            value: The value the field should equal

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        self._filters.append((&#34;equals&#34;, field, value))
        return self

    def in_list(self, field: str, values: list) -&gt; Builder:
        &#34;&#34;&#34;Filters if the provided field matches a value in a list.

        In general, an &#39;in&#39; filter will be bound to the plural form of the field.
        Eg. `userid` for an equal filter, `userids` for a list filter.

        Here we only append an &#39;s&#39; to the field name if it doesn&#39;t have one yet.
        This way we can be as forgiving as possible for developers by accepting:
        `filter.in_list(&#34;userid&#34;, [1, 2])` or `filter.in_list(&#34;userids&#34;, [1, 2])`.

        Of course the FreshBooks API is not 100% consistent, so there are a couple
        of unique cases that may not be handled.

        Args:
            field: The API response field to filter on
            values: List of values the field should one of

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        if field[-1] != &#34;s&#34;:
            field = f&#34;{field}s&#34;
        self._filters.append((&#34;in&#34;, field, values))
        return self

    def like(self, field: str, value: Any) -&gt; Builder:
        &#34;&#34;&#34;Filters for a match contained within the field being searched. For example,
        &#34;leaf&#34; will Like-match &#34;aleaf&#34; and &#34;leafy&#34;, but not &#34;leav&#34;, and &#34;leafs&#34; would
        not Like-match &#34;leaf&#34;.

        Args:
            field: The API response field to filter on
            value: The value the field should contain

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        self._filters.append((&#34;like&#34;, field, value))
        return self

    def date_time(self, field: str, value: Union[str, datetime]) -&gt; Builder:
        &#34;&#34;&#34;Filters for entries that come before or after a particular time, as specified
        by the field. Eg. &#34;updated_since&#34; on Time Entries will return time entries updated
        after the provided time.

        The url parameter must be in ISO 8601 format (eg. 2010-10-17T05:45:53Z)

        Example:

        - `filter.date_time(&#34;updated_since&#34;, &#34;2020-10-17T13:14:07&#34;)` will yield `&amp;updated_since=2020-10-17T13:14:07`

        Args:
            field: The API response field to filter on
            value: The datetime, or ISO 8601 format string value

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        if isinstance(value, datetime):
            value = value.isoformat()
        self._filters.append((&#34;date_time&#34;, field, value))
        return self

    def between(self, field: str, min: Optional[Any] = None, max: Optional[Any] = None) -&gt; Builder:
        &#34;&#34;&#34;Filters results where the provided field is between two values.

        In general &#39;between&#39; filters end in a `_min` or `_max` (as in `amount_min` or `amount_max`)
        or `_date` (as in `start_date`, `end_date`). If the provided field does not end in
        `_min`/`_max` or `_date`, then the appropriate `_min`/`_max` will be appended.

        For date fields, you can pass the iso format `2020-10-17` or a `datetime` or `date` object, which
        will be converted to the proper string format.

        Examples:

        - `filter.between(&#34;amount&#34;, 1, 10)` will yield filters `&amp;search[amount_min]=1&amp;search[amount_max]=10`
        - `filter.between(&#34;amount_min&#34;, min=1)` will yield filter `&amp;search[amount_min]=1`
        - `filter.between(&#34;amount_max&#34;, max=10)` will yield filter `&amp;search[amount_max]=10`
        - `filter.between(&#34;start_date&#34;, &#34;2020-10-17&#34;)` will yield filter `&amp;search[start_date]=2020-10-17`
        - `filter.between(&#34;start_date&#34;, datetime.date(year=2020, month=10, day=17))` will yield filter
          `&amp;search[start_date]=2020-10-17`

        Args:
            field: The API response field to filter on
            min: (Optional) The value the field should be greater than (or equal to)
            max: (Optional) The value the field should be less than (or equal to)

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        if min:
            min_field = self._convert_between_field_name(field, &#34;_min&#34;)
            min_value = self._convert_between_value(min)
            self._filters.append((&#34;between&#34;, min_field, min_value))
        if max:
            max_field = self._convert_between_field_name(field, &#34;_max&#34;)
            max_value = self._convert_between_value(max)
            self._filters.append((&#34;between&#34;, max_field, max_value))
        return self

    def _convert_between_field_name(self, field: str, min_max: str) -&gt; str:
        if field[-4:] not in [&#34;_min&#34;, &#34;_max&#34;] and field[-5:] != &#34;_date&#34;:
            return f&#34;{field}{min_max}&#34;
        return field

    def _convert_between_value(self, value: Union[str, Any]) -&gt; str:
        if isinstance(value, datetime):
            return value.date().isoformat()
        elif isinstance(value, date):
            return value.isoformat()
        return value

    def build(self, resource_name: Optional[str] = None) -&gt; str:
        &#34;&#34;&#34;Builds the query string parameters from the FilterBuilder.

        Args:
            resource_name: The type of resource to generate the query string for.
                           Eg. AccountingResource, ProjectsResource

        Returns:
            The built query string
        &#34;&#34;&#34;
        is_accounting_like = False
        if not resource_name or resource_name in [&#34;AccountingResource&#34;, &#34;EventsResource&#34;]:
            is_accounting_like = True
        query_string = &#34;&#34;
        for filter_type, field, value in self._filters:
            if filter_type in [&#34;like&#34;, &#34;between&#34;] or (is_accounting_like and filter_type == &#34;equals&#34;):
                query_string = f&#34;{query_string}&amp;search[{field}]={value}&#34;
            if filter_type == &#34;in&#34;:
                for val in value:
                    query_string = f&#34;{query_string}&amp;search[{field}][]={val}&#34;
            if filter_type in [&#34;bool&#34;, &#34;date_time&#34;] or (not is_accounting_like and filter_type == &#34;equals&#34;):
                query_string = f&#34;{query_string}&amp;{field}={value}&#34;
        return query_string</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="freshbooks.builders.filter.FilterBuilder"><code class="flex name class">
<span>class <span class="ident">FilterBuilder</span></span>
</code></dt>
<dd>
<div class="desc"><p>Builder for making filtered list queries.</p>
<p>Filters can be builts with the methods:
<code>equals</code>, <code>in_list</code>, <code>like</code>, <code>between</code>, and <code>boolean</code>, <code>date_time</code>
which can be chained together.</p>
<pre><code class="language-python">&gt;&gt;&gt; from freshbooks import FilterBuilder

&gt;&gt;&gt; f = FilterBuilder()
&gt;&gt;&gt; f.like(&quot;email_like&quot;, &quot;@freshbooks.com&quot;)
FilterBuilder(&amp;search[email_like]=@freshbooks.com)

&gt;&gt;&gt; f = FilterBuilder()
&gt;&gt;&gt; f.in_list(&quot;clientids&quot;, [123, 456]).boolean(&quot;active&quot;, False)
FilterBuilder(&amp;search[clientids][]=123&amp;search[clientids][]=456&amp;active=False)

&gt;&gt;&gt; f = FilterBuilder()
&gt;&gt;&gt; f.boolean(&quot;active&quot;, False).in_list(&quot;clientids&quot;, [123, 456])
FilterBuilder(&amp;active=False&amp;search[clientids][]=123&amp;search[clientids][]=456)

&gt;&gt;&gt; f = FilterBuilder()
&gt;&gt;&gt; f.between(&quot;amount&quot;, 1, 10)
FilterBuilder(&amp;search[amount_min]=1&amp;search[amount_max]=10)

&gt;&gt;&gt; f = FilterBuilder()
&gt;&gt;&gt; f.between(&quot;start_date&quot;, date.today())
FilterBuilder(&amp;search[start_date]=2020-11-21)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilterBuilder(Builder):
    &#34;&#34;&#34;Builder for making filtered list queries.

    Filters can be builts with the methods:
    `equals`, `in_list`, `like`, `between`, and `boolean`, `date_time`
    which can be chained together.

    ```python
    &gt;&gt;&gt; from freshbooks import FilterBuilder

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.like(&#34;email_like&#34;, &#34;@freshbooks.com&#34;)
    FilterBuilder(&amp;search[email_like]=@freshbooks.com)

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.in_list(&#34;clientids&#34;, [123, 456]).boolean(&#34;active&#34;, False)
    FilterBuilder(&amp;search[clientids][]=123&amp;search[clientids][]=456&amp;active=False)

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.boolean(&#34;active&#34;, False).in_list(&#34;clientids&#34;, [123, 456])
    FilterBuilder(&amp;active=False&amp;search[clientids][]=123&amp;search[clientids][]=456)

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.between(&#34;amount&#34;, 1, 10)
    FilterBuilder(&amp;search[amount_min]=1&amp;search[amount_max]=10)

    &gt;&gt;&gt; f = FilterBuilder()
    &gt;&gt;&gt; f.between(&#34;start_date&#34;, date.today())
    FilterBuilder(&amp;search[start_date]=2020-11-21)
    ```
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self._filters: List[Tuple[str, str, Any]] = []

    def __str__(self) -&gt; str:
        query_string = self.build()
        return f&#34;FilterBuilder({query_string})&#34;

    def __repr__(self) -&gt; str:  # pragma: no cover
        query_string = self.build()
        return f&#34;FilterBuilder({query_string})&#34;

    def boolean(self, field: str, value: bool) -&gt; Builder:
        &#34;&#34;&#34;Filters results where the field is equal to true or false.

        Example:
        `filter.boolean(&#34;active&#34;, False)` will yield the filter `&amp;active=false`

        Args:
            field: The API response field to filter on
            value: True or False

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        self._filters.append((&#34;bool&#34;, field, value))
        return self

    def equals(self, field: str, value: Any) -&gt; Builder:
        &#34;&#34;&#34;Filters results where the field is equal to the provided value.

        Example:
        `filter.equals(&#34;username&#34;, &#34;Bob&#34;)` will yield the filter `&amp;search[username]=Bob`

        Args:
            field: The API response field to filter on
            value: The value the field should equal

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        self._filters.append((&#34;equals&#34;, field, value))
        return self

    def in_list(self, field: str, values: list) -&gt; Builder:
        &#34;&#34;&#34;Filters if the provided field matches a value in a list.

        In general, an &#39;in&#39; filter will be bound to the plural form of the field.
        Eg. `userid` for an equal filter, `userids` for a list filter.

        Here we only append an &#39;s&#39; to the field name if it doesn&#39;t have one yet.
        This way we can be as forgiving as possible for developers by accepting:
        `filter.in_list(&#34;userid&#34;, [1, 2])` or `filter.in_list(&#34;userids&#34;, [1, 2])`.

        Of course the FreshBooks API is not 100% consistent, so there are a couple
        of unique cases that may not be handled.

        Args:
            field: The API response field to filter on
            values: List of values the field should one of

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        if field[-1] != &#34;s&#34;:
            field = f&#34;{field}s&#34;
        self._filters.append((&#34;in&#34;, field, values))
        return self

    def like(self, field: str, value: Any) -&gt; Builder:
        &#34;&#34;&#34;Filters for a match contained within the field being searched. For example,
        &#34;leaf&#34; will Like-match &#34;aleaf&#34; and &#34;leafy&#34;, but not &#34;leav&#34;, and &#34;leafs&#34; would
        not Like-match &#34;leaf&#34;.

        Args:
            field: The API response field to filter on
            value: The value the field should contain

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        self._filters.append((&#34;like&#34;, field, value))
        return self

    def date_time(self, field: str, value: Union[str, datetime]) -&gt; Builder:
        &#34;&#34;&#34;Filters for entries that come before or after a particular time, as specified
        by the field. Eg. &#34;updated_since&#34; on Time Entries will return time entries updated
        after the provided time.

        The url parameter must be in ISO 8601 format (eg. 2010-10-17T05:45:53Z)

        Example:

        - `filter.date_time(&#34;updated_since&#34;, &#34;2020-10-17T13:14:07&#34;)` will yield `&amp;updated_since=2020-10-17T13:14:07`

        Args:
            field: The API response field to filter on
            value: The datetime, or ISO 8601 format string value

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        if isinstance(value, datetime):
            value = value.isoformat()
        self._filters.append((&#34;date_time&#34;, field, value))
        return self

    def between(self, field: str, min: Optional[Any] = None, max: Optional[Any] = None) -&gt; Builder:
        &#34;&#34;&#34;Filters results where the provided field is between two values.

        In general &#39;between&#39; filters end in a `_min` or `_max` (as in `amount_min` or `amount_max`)
        or `_date` (as in `start_date`, `end_date`). If the provided field does not end in
        `_min`/`_max` or `_date`, then the appropriate `_min`/`_max` will be appended.

        For date fields, you can pass the iso format `2020-10-17` or a `datetime` or `date` object, which
        will be converted to the proper string format.

        Examples:

        - `filter.between(&#34;amount&#34;, 1, 10)` will yield filters `&amp;search[amount_min]=1&amp;search[amount_max]=10`
        - `filter.between(&#34;amount_min&#34;, min=1)` will yield filter `&amp;search[amount_min]=1`
        - `filter.between(&#34;amount_max&#34;, max=10)` will yield filter `&amp;search[amount_max]=10`
        - `filter.between(&#34;start_date&#34;, &#34;2020-10-17&#34;)` will yield filter `&amp;search[start_date]=2020-10-17`
        - `filter.between(&#34;start_date&#34;, datetime.date(year=2020, month=10, day=17))` will yield filter
          `&amp;search[start_date]=2020-10-17`

        Args:
            field: The API response field to filter on
            min: (Optional) The value the field should be greater than (or equal to)
            max: (Optional) The value the field should be less than (or equal to)

        Returns:
            The FilterBuilder instance
        &#34;&#34;&#34;
        if min:
            min_field = self._convert_between_field_name(field, &#34;_min&#34;)
            min_value = self._convert_between_value(min)
            self._filters.append((&#34;between&#34;, min_field, min_value))
        if max:
            max_field = self._convert_between_field_name(field, &#34;_max&#34;)
            max_value = self._convert_between_value(max)
            self._filters.append((&#34;between&#34;, max_field, max_value))
        return self

    def _convert_between_field_name(self, field: str, min_max: str) -&gt; str:
        if field[-4:] not in [&#34;_min&#34;, &#34;_max&#34;] and field[-5:] != &#34;_date&#34;:
            return f&#34;{field}{min_max}&#34;
        return field

    def _convert_between_value(self, value: Union[str, Any]) -&gt; str:
        if isinstance(value, datetime):
            return value.date().isoformat()
        elif isinstance(value, date):
            return value.isoformat()
        return value

    def build(self, resource_name: Optional[str] = None) -&gt; str:
        &#34;&#34;&#34;Builds the query string parameters from the FilterBuilder.

        Args:
            resource_name: The type of resource to generate the query string for.
                           Eg. AccountingResource, ProjectsResource

        Returns:
            The built query string
        &#34;&#34;&#34;
        is_accounting_like = False
        if not resource_name or resource_name in [&#34;AccountingResource&#34;, &#34;EventsResource&#34;]:
            is_accounting_like = True
        query_string = &#34;&#34;
        for filter_type, field, value in self._filters:
            if filter_type in [&#34;like&#34;, &#34;between&#34;] or (is_accounting_like and filter_type == &#34;equals&#34;):
                query_string = f&#34;{query_string}&amp;search[{field}]={value}&#34;
            if filter_type == &#34;in&#34;:
                for val in value:
                    query_string = f&#34;{query_string}&amp;search[{field}][]={val}&#34;
            if filter_type in [&#34;bool&#34;, &#34;date_time&#34;] or (not is_accounting_like and filter_type == &#34;equals&#34;):
                query_string = f&#34;{query_string}&amp;{field}={value}&#34;
        return query_string</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="freshbooks.builders.Builder" href="index.html#freshbooks.builders.Builder">Builder</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="freshbooks.builders.filter.FilterBuilder.between"><code class="name flex">
<span>def <span class="ident">between</span></span>(<span>self, field: str, min: Optional[Any] = None, max: Optional[Any] = None) ‑> <a title="freshbooks.builders.Builder" href="index.html#freshbooks.builders.Builder">Builder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Filters results where the provided field is between two values.</p>
<p>In general 'between' filters end in a <code>_min</code> or <code>_max</code> (as in <code>amount_min</code> or <code>amount_max</code>)
or <code>_date</code> (as in <code>start_date</code>, <code>end_date</code>). If the provided field does not end in
<code>_min</code>/<code>_max</code> or <code>_date</code>, then the appropriate <code>_min</code>/<code>_max</code> will be appended.</p>
<p>For date fields, you can pass the iso format <code>2020-10-17</code> or a <code>datetime</code> or <code>date</code> object, which
will be converted to the proper string format.</p>
<p>Examples:</p>
<ul>
<li><code>filter.between("amount", 1, 10)</code> will yield filters <code>&amp;search[amount_min]=1&amp;search[amount_max]=10</code></li>
<li><code>filter.between("amount_min", min=1)</code> will yield filter <code>&amp;search[amount_min]=1</code></li>
<li><code>filter.between("amount_max", max=10)</code> will yield filter <code>&amp;search[amount_max]=10</code></li>
<li><code>filter.between("start_date", "2020-10-17")</code> will yield filter <code>&amp;search[start_date]=2020-10-17</code></li>
<li><code>filter.between("start_date", datetime.date(year=2020, month=10, day=17))</code> will yield filter
<code>&amp;search[start_date]=2020-10-17</code></li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>The API response field to filter on</dd>
<dt><strong><code>min</code></strong></dt>
<dd>(Optional) The value the field should be greater than (or equal to)</dd>
<dt><strong><code>max</code></strong></dt>
<dd>(Optional) The value the field should be less than (or equal to)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The FilterBuilder instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def between(self, field: str, min: Optional[Any] = None, max: Optional[Any] = None) -&gt; Builder:
    &#34;&#34;&#34;Filters results where the provided field is between two values.

    In general &#39;between&#39; filters end in a `_min` or `_max` (as in `amount_min` or `amount_max`)
    or `_date` (as in `start_date`, `end_date`). If the provided field does not end in
    `_min`/`_max` or `_date`, then the appropriate `_min`/`_max` will be appended.

    For date fields, you can pass the iso format `2020-10-17` or a `datetime` or `date` object, which
    will be converted to the proper string format.

    Examples:

    - `filter.between(&#34;amount&#34;, 1, 10)` will yield filters `&amp;search[amount_min]=1&amp;search[amount_max]=10`
    - `filter.between(&#34;amount_min&#34;, min=1)` will yield filter `&amp;search[amount_min]=1`
    - `filter.between(&#34;amount_max&#34;, max=10)` will yield filter `&amp;search[amount_max]=10`
    - `filter.between(&#34;start_date&#34;, &#34;2020-10-17&#34;)` will yield filter `&amp;search[start_date]=2020-10-17`
    - `filter.between(&#34;start_date&#34;, datetime.date(year=2020, month=10, day=17))` will yield filter
      `&amp;search[start_date]=2020-10-17`

    Args:
        field: The API response field to filter on
        min: (Optional) The value the field should be greater than (or equal to)
        max: (Optional) The value the field should be less than (or equal to)

    Returns:
        The FilterBuilder instance
    &#34;&#34;&#34;
    if min:
        min_field = self._convert_between_field_name(field, &#34;_min&#34;)
        min_value = self._convert_between_value(min)
        self._filters.append((&#34;between&#34;, min_field, min_value))
    if max:
        max_field = self._convert_between_field_name(field, &#34;_max&#34;)
        max_value = self._convert_between_value(max)
        self._filters.append((&#34;between&#34;, max_field, max_value))
    return self</code></pre>
</details>
</dd>
<dt id="freshbooks.builders.filter.FilterBuilder.boolean"><code class="name flex">
<span>def <span class="ident">boolean</span></span>(<span>self, field: str, value: bool) ‑> <a title="freshbooks.builders.Builder" href="index.html#freshbooks.builders.Builder">Builder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Filters results where the field is equal to true or false.</p>
<p>Example:
<code>filter.boolean("active", False)</code> will yield the filter <code>&amp;active=false</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>The API response field to filter on</dd>
<dt><strong><code>value</code></strong></dt>
<dd>True or False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The FilterBuilder instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boolean(self, field: str, value: bool) -&gt; Builder:
    &#34;&#34;&#34;Filters results where the field is equal to true or false.

    Example:
    `filter.boolean(&#34;active&#34;, False)` will yield the filter `&amp;active=false`

    Args:
        field: The API response field to filter on
        value: True or False

    Returns:
        The FilterBuilder instance
    &#34;&#34;&#34;
    self._filters.append((&#34;bool&#34;, field, value))
    return self</code></pre>
</details>
</dd>
<dt id="freshbooks.builders.filter.FilterBuilder.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, resource_name: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Builds the query string parameters from the FilterBuilder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_name</code></strong></dt>
<dd>The type of resource to generate the query string for.
Eg. AccountingResource, ProjectsResource</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The built query string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, resource_name: Optional[str] = None) -&gt; str:
    &#34;&#34;&#34;Builds the query string parameters from the FilterBuilder.

    Args:
        resource_name: The type of resource to generate the query string for.
                       Eg. AccountingResource, ProjectsResource

    Returns:
        The built query string
    &#34;&#34;&#34;
    is_accounting_like = False
    if not resource_name or resource_name in [&#34;AccountingResource&#34;, &#34;EventsResource&#34;]:
        is_accounting_like = True
    query_string = &#34;&#34;
    for filter_type, field, value in self._filters:
        if filter_type in [&#34;like&#34;, &#34;between&#34;] or (is_accounting_like and filter_type == &#34;equals&#34;):
            query_string = f&#34;{query_string}&amp;search[{field}]={value}&#34;
        if filter_type == &#34;in&#34;:
            for val in value:
                query_string = f&#34;{query_string}&amp;search[{field}][]={val}&#34;
        if filter_type in [&#34;bool&#34;, &#34;date_time&#34;] or (not is_accounting_like and filter_type == &#34;equals&#34;):
            query_string = f&#34;{query_string}&amp;{field}={value}&#34;
    return query_string</code></pre>
</details>
</dd>
<dt id="freshbooks.builders.filter.FilterBuilder.date_time"><code class="name flex">
<span>def <span class="ident">date_time</span></span>(<span>self, field: str, value: Union[str, datetime.datetime]) ‑> <a title="freshbooks.builders.Builder" href="index.html#freshbooks.builders.Builder">Builder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Filters for entries that come before or after a particular time, as specified
by the field. Eg. "updated_since" on Time Entries will return time entries updated
after the provided time.</p>
<p>The url parameter must be in ISO 8601 format (eg. 2010-10-17T05:45:53Z)</p>
<p>Example:</p>
<ul>
<li><code>filter.date_time("updated_since", "2020-10-17T13:14:07")</code> will yield <code>&amp;updated_since=2020-10-17T13:14:07</code></li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>The API response field to filter on</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The datetime, or ISO 8601 format string value</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The FilterBuilder instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date_time(self, field: str, value: Union[str, datetime]) -&gt; Builder:
    &#34;&#34;&#34;Filters for entries that come before or after a particular time, as specified
    by the field. Eg. &#34;updated_since&#34; on Time Entries will return time entries updated
    after the provided time.

    The url parameter must be in ISO 8601 format (eg. 2010-10-17T05:45:53Z)

    Example:

    - `filter.date_time(&#34;updated_since&#34;, &#34;2020-10-17T13:14:07&#34;)` will yield `&amp;updated_since=2020-10-17T13:14:07`

    Args:
        field: The API response field to filter on
        value: The datetime, or ISO 8601 format string value

    Returns:
        The FilterBuilder instance
    &#34;&#34;&#34;
    if isinstance(value, datetime):
        value = value.isoformat()
    self._filters.append((&#34;date_time&#34;, field, value))
    return self</code></pre>
</details>
</dd>
<dt id="freshbooks.builders.filter.FilterBuilder.equals"><code class="name flex">
<span>def <span class="ident">equals</span></span>(<span>self, field: str, value: Any) ‑> <a title="freshbooks.builders.Builder" href="index.html#freshbooks.builders.Builder">Builder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Filters results where the field is equal to the provided value.</p>
<p>Example:
<code>filter.equals("username", "Bob")</code> will yield the filter <code>&amp;search[username]=Bob</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>The API response field to filter on</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The value the field should equal</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The FilterBuilder instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equals(self, field: str, value: Any) -&gt; Builder:
    &#34;&#34;&#34;Filters results where the field is equal to the provided value.

    Example:
    `filter.equals(&#34;username&#34;, &#34;Bob&#34;)` will yield the filter `&amp;search[username]=Bob`

    Args:
        field: The API response field to filter on
        value: The value the field should equal

    Returns:
        The FilterBuilder instance
    &#34;&#34;&#34;
    self._filters.append((&#34;equals&#34;, field, value))
    return self</code></pre>
</details>
</dd>
<dt id="freshbooks.builders.filter.FilterBuilder.in_list"><code class="name flex">
<span>def <span class="ident">in_list</span></span>(<span>self, field: str, values: list) ‑> <a title="freshbooks.builders.Builder" href="index.html#freshbooks.builders.Builder">Builder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Filters if the provided field matches a value in a list.</p>
<p>In general, an 'in' filter will be bound to the plural form of the field.
Eg. <code>userid</code> for an equal filter, <code>userids</code> for a list filter.</p>
<p>Here we only append an 's' to the field name if it doesn't have one yet.
This way we can be as forgiving as possible for developers by accepting:
<code>filter.in_list("userid", [1, 2])</code> or <code>filter.in_list("userids", [1, 2])</code>.</p>
<p>Of course the FreshBooks API is not 100% consistent, so there are a couple
of unique cases that may not be handled.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>The API response field to filter on</dd>
<dt><strong><code>values</code></strong></dt>
<dd>List of values the field should one of</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The FilterBuilder instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_list(self, field: str, values: list) -&gt; Builder:
    &#34;&#34;&#34;Filters if the provided field matches a value in a list.

    In general, an &#39;in&#39; filter will be bound to the plural form of the field.
    Eg. `userid` for an equal filter, `userids` for a list filter.

    Here we only append an &#39;s&#39; to the field name if it doesn&#39;t have one yet.
    This way we can be as forgiving as possible for developers by accepting:
    `filter.in_list(&#34;userid&#34;, [1, 2])` or `filter.in_list(&#34;userids&#34;, [1, 2])`.

    Of course the FreshBooks API is not 100% consistent, so there are a couple
    of unique cases that may not be handled.

    Args:
        field: The API response field to filter on
        values: List of values the field should one of

    Returns:
        The FilterBuilder instance
    &#34;&#34;&#34;
    if field[-1] != &#34;s&#34;:
        field = f&#34;{field}s&#34;
    self._filters.append((&#34;in&#34;, field, values))
    return self</code></pre>
</details>
</dd>
<dt id="freshbooks.builders.filter.FilterBuilder.like"><code class="name flex">
<span>def <span class="ident">like</span></span>(<span>self, field: str, value: Any) ‑> <a title="freshbooks.builders.Builder" href="index.html#freshbooks.builders.Builder">Builder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Filters for a match contained within the field being searched. For example,
"leaf" will Like-match "aleaf" and "leafy", but not "leav", and "leafs" would
not Like-match "leaf".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong></dt>
<dd>The API response field to filter on</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The value the field should contain</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The FilterBuilder instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def like(self, field: str, value: Any) -&gt; Builder:
    &#34;&#34;&#34;Filters for a match contained within the field being searched. For example,
    &#34;leaf&#34; will Like-match &#34;aleaf&#34; and &#34;leafy&#34;, but not &#34;leav&#34;, and &#34;leafs&#34; would
    not Like-match &#34;leaf&#34;.

    Args:
        field: The API response field to filter on
        value: The value the field should contain

    Returns:
        The FilterBuilder instance
    &#34;&#34;&#34;
    self._filters.append((&#34;like&#34;, field, value))
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="freshbooks.builders" href="index.html">freshbooks.builders</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="freshbooks.builders.filter.FilterBuilder" href="#freshbooks.builders.filter.FilterBuilder">FilterBuilder</a></code></h4>
<ul class="two-column">
<li><code><a title="freshbooks.builders.filter.FilterBuilder.between" href="#freshbooks.builders.filter.FilterBuilder.between">between</a></code></li>
<li><code><a title="freshbooks.builders.filter.FilterBuilder.boolean" href="#freshbooks.builders.filter.FilterBuilder.boolean">boolean</a></code></li>
<li><code><a title="freshbooks.builders.filter.FilterBuilder.build" href="#freshbooks.builders.filter.FilterBuilder.build">build</a></code></li>
<li><code><a title="freshbooks.builders.filter.FilterBuilder.date_time" href="#freshbooks.builders.filter.FilterBuilder.date_time">date_time</a></code></li>
<li><code><a title="freshbooks.builders.filter.FilterBuilder.equals" href="#freshbooks.builders.filter.FilterBuilder.equals">equals</a></code></li>
<li><code><a title="freshbooks.builders.filter.FilterBuilder.in_list" href="#freshbooks.builders.filter.FilterBuilder.in_list">in_list</a></code></li>
<li><code><a title="freshbooks.builders.filter.FilterBuilder.like" href="#freshbooks.builders.filter.FilterBuilder.like">like</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>